{
    "title": "$:/plugins/tiddlywiki/filesystem",
    "description": "Local filesystem syncadaptor",
    "author": "JeremyRuston",
    "core-version": ">=5.0.0",
    "list": "readme",
    "version": "5.1.10",
    "plugin-type": "plugin",
    "dependents": "",
    "type": "application/json",
    "text": "{\n    \"tiddlers\": {\n        \"$:/plugins/tiddlywiki/filesystem/filesystemadaptor.js\": {\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/tiddlywiki/filesystem/filesystemadaptor.js\\ntype: application/javascript\\nmodule-type: syncadaptor\\n\\nA sync adaptor module for synchronising with the local filesystem via node.js APIs\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n// Get a reference to the file system\\nvar fs = $tw.node ? require(\\\"fs\\\") : null,\\n\\tpath = $tw.node ? require(\\\"path\\\") : null;\\n\\nfunction FileSystemAdaptor(options) {\\n\\tvar self = this;\\n\\tthis.wiki = options.wiki;\\n\\tthis.logger = new $tw.utils.Logger(\\\"FileSystem\\\");\\n\\t// Create the <wiki>/tiddlers folder if it doesn't exist\\n\\t$tw.utils.createDirectory($tw.boot.wikiTiddlersPath);\\n}\\n\\nFileSystemAdaptor.prototype.getTiddlerInfo = function(tiddler) {\\n\\treturn {};\\n};\\n\\n$tw.config.typeInfo = {\\n\\t\\\"text/vnd.tiddlywiki\\\": {\\n\\t\\tfileType: \\\"application/x-tiddler\\\",\\n\\t\\textension: \\\".tid\\\"\\n\\t},\\n\\t\\\"image/jpeg\\\" : {\\n\\t\\thasMetaFile: true\\n\\t}\\n};\\n\\n$tw.config.typeTemplates = {\\n\\t\\\"application/x-tiddler\\\": \\\"$:/core/templates/tid-tiddler\\\"\\n};\\n\\nFileSystemAdaptor.prototype.getTiddlerFileInfo = function(tiddler,callback) {\\n\\t// See if we've already got information about this file\\n\\tvar self = this,\\n\\t\\ttitle = tiddler.fields.title,\\n\\t\\tfileInfo = $tw.boot.files[title];\\n\\t// Get information about how to save tiddlers of this type\\n\\tvar type = tiddler.fields.type || \\\"text/vnd.tiddlywiki\\\",\\n\\t\\ttypeInfo = $tw.config.typeInfo[type];\\n\\tif(!typeInfo) {\\n\\t\\ttypeInfo = $tw.config.typeInfo[\\\"text/vnd.tiddlywiki\\\"];\\n\\t}\\n\\tvar extension = typeInfo.extension || \\\"\\\";\\n\\tif(!fileInfo) {\\n\\t\\t// If not, we'll need to generate it\\n\\t\\t// Start by getting a list of the existing files in the directory\\n\\t\\tfs.readdir($tw.boot.wikiTiddlersPath,function(err,files) {\\n\\t\\t\\tif(err) {\\n\\t\\t\\t\\treturn callback(err);\\n\\t\\t\\t}\\n\\t\\t\\t// Assemble the new fileInfo\\n\\t\\t\\tfileInfo = {};\\n\\t\\t\\tfileInfo.filepath = $tw.boot.wikiTiddlersPath + path.sep + self.generateTiddlerFilename(title,extension,files);\\n\\t\\t\\tfileInfo.type = typeInfo.fileType || tiddler.fields.type;\\n\\t\\t\\tfileInfo.hasMetaFile = typeInfo.hasMetaFile;\\n\\t\\t\\t// Save the newly created fileInfo\\n\\t\\t\\t$tw.boot.files[title] = fileInfo;\\n\\t\\t\\t// Pass it to the callback\\n\\t\\t\\tcallback(null,fileInfo);\\n\\t\\t});\\n\\t} else {\\n\\t\\t// Otherwise just invoke the callback\\n\\t\\tcallback(null,fileInfo);\\n\\t}\\n};\\n\\n/*\\nTransliterate string from cyrillic russian to latin\\n*/\\n var transliterate = function(cyrillyc) {\\n\\tvar a = {\\\"Ё\\\":\\\"YO\\\",\\\"Й\\\":\\\"I\\\",\\\"Ц\\\":\\\"TS\\\",\\\"У\\\":\\\"U\\\",\\\"К\\\":\\\"K\\\",\\\"Е\\\":\\\"E\\\",\\\"Н\\\":\\\"N\\\",\\\"Г\\\":\\\"G\\\",\\\"Ш\\\":\\\"SH\\\",\\\"Щ\\\":\\\"SCH\\\",\\\"З\\\":\\\"Z\\\",\\\"Х\\\":\\\"H\\\",\\\"Ъ\\\":\\\"'\\\",\\\"ё\\\":\\\"yo\\\",\\\"й\\\":\\\"i\\\",\\\"ц\\\":\\\"ts\\\",\\\"у\\\":\\\"u\\\",\\\"к\\\":\\\"k\\\",\\\"е\\\":\\\"e\\\",\\\"н\\\":\\\"n\\\",\\\"г\\\":\\\"g\\\",\\\"ш\\\":\\\"sh\\\",\\\"щ\\\":\\\"sch\\\",\\\"з\\\":\\\"z\\\",\\\"х\\\":\\\"h\\\",\\\"ъ\\\":\\\"'\\\",\\\"Ф\\\":\\\"F\\\",\\\"Ы\\\":\\\"I\\\",\\\"В\\\":\\\"V\\\",\\\"А\\\":\\\"a\\\",\\\"П\\\":\\\"P\\\",\\\"Р\\\":\\\"R\\\",\\\"О\\\":\\\"O\\\",\\\"Л\\\":\\\"L\\\",\\\"Д\\\":\\\"D\\\",\\\"Ж\\\":\\\"ZH\\\",\\\"Э\\\":\\\"E\\\",\\\"ф\\\":\\\"f\\\",\\\"ы\\\":\\\"i\\\",\\\"в\\\":\\\"v\\\",\\\"а\\\":\\\"a\\\",\\\"п\\\":\\\"p\\\",\\\"р\\\":\\\"r\\\",\\\"о\\\":\\\"o\\\",\\\"л\\\":\\\"l\\\",\\\"д\\\":\\\"d\\\",\\\"ж\\\":\\\"zh\\\",\\\"э\\\":\\\"e\\\",\\\"Я\\\":\\\"Ya\\\",\\\"Ч\\\":\\\"CH\\\",\\\"С\\\":\\\"S\\\",\\\"М\\\":\\\"M\\\",\\\"И\\\":\\\"I\\\",\\\"Т\\\":\\\"T\\\",\\\"Ь\\\":\\\"'\\\",\\\"Б\\\":\\\"B\\\",\\\"Ю\\\":\\\"YU\\\",\\\"я\\\":\\\"ya\\\",\\\"ч\\\":\\\"ch\\\",\\\"с\\\":\\\"s\\\",\\\"м\\\":\\\"m\\\",\\\"и\\\":\\\"i\\\",\\\"т\\\":\\\"t\\\",\\\"ь\\\":\\\"'\\\",\\\"б\\\":\\\"b\\\",\\\"ю\\\":\\\"yu\\\"};\\n\\treturn cyrillyc.split(\\\"\\\").map(function (char) {\\n\\t\\treturn a[char] || char;\\n\\t}).join(\\\"\\\");\\n};\\n\\n/*\\nGiven a tiddler title and an array of existing filenames, generate a new legal filename for the title, case insensitively avoiding the array of existing filenames\\n*/\\nFileSystemAdaptor.prototype.generateTiddlerFilename = function(title,extension,existingFilenames) {\\n\\t// First remove any of the characters that are illegal in Windows filenames\\n\\tvar baseFilename = transliterate(title.replace(/<|>|\\\\:|\\\\\\\"|\\\\/|\\\\\\\\|\\\\||\\\\?|\\\\*|\\\\^|\\\\s/g,\\\"_\\\"));\\n\\t// Truncate the filename if it is too long\\n\\tif(baseFilename.length > 200) {\\n\\t\\tbaseFilename = baseFilename.substr(0,200);\\n\\t}\\n\\t// Start with the base filename plus the extension\\n\\tvar filename = baseFilename + extension,\\n\\t\\tcount = 1;\\n\\t// Add a discriminator if we're clashing with an existing filename while\\n\\t// handling case-insensitive filesystems (NTFS, FAT/FAT32, etc.)\\n\\twhile(existingFilenames.some(function(value) {return value.toLocaleLowerCase() === filename.toLocaleLowerCase();})) {\\n\\t\\tfilename = baseFilename + \\\" \\\" + (count++) + extension;\\n\\t}\\n\\treturn filename;\\n};\\n\\n/*\\nSave a tiddler and invoke the callback with (err,adaptorInfo,revision)\\n*/\\nFileSystemAdaptor.prototype.saveTiddler = function(tiddler,callback) {\\n\\tvar self = this;\\n\\tthis.getTiddlerFileInfo(tiddler,function(err,fileInfo) {\\n\\t\\tvar template, content, encoding,\\n\\t\\t\\t_finish = function() {\\n\\t\\t\\t\\tcallback(null, {}, 0);\\n\\t\\t\\t};\\n\\t\\tif(err) {\\n\\t\\t\\treturn callback(err);\\n\\t\\t}\\n\\t\\tvar typeInfo = $tw.config.contentTypeInfo[fileInfo.type];\\n\\t\\tif(fileInfo.hasMetaFile || typeInfo.encoding === \\\"base64\\\") {\\n\\t\\t\\t// Save the tiddler as a separate body and meta file\\n\\t\\t\\tfs.writeFile(fileInfo.filepath,tiddler.fields.text,{encoding: typeInfo.encoding},function(err) {\\n\\t\\t\\t\\tif(err) {\\n\\t\\t\\t\\t\\treturn callback(err);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcontent = self.wiki.renderTiddler(\\\"text/plain\\\",\\\"$:/core/templates/tiddler-metadata\\\",{variables: {currentTiddler: tiddler.fields.title}});\\n\\t\\t\\t\\tfs.writeFile(fileInfo.filepath + \\\".meta\\\",content,{encoding: \\\"utf8\\\"},function (err) {\\n\\t\\t\\t\\t\\tif(err) {\\n\\t\\t\\t\\t\\t\\treturn callback(err);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tself.logger.log(\\\"Saved file\\\",fileInfo.filepath);\\n\\t\\t\\t\\t\\t_finish();\\n\\t\\t\\t\\t});\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\t// Save the tiddler as a self contained templated file\\n\\t\\t\\ttemplate = $tw.config.typeTemplates[fileInfo.type];\\n\\t\\t\\tcontent = self.wiki.renderTiddler(\\\"text/plain\\\",template,{variables: {currentTiddler: tiddler.fields.title}});\\n\\t\\t\\tfs.writeFile(fileInfo.filepath,content,{encoding: \\\"utf8\\\"},function (err) {\\n\\t\\t\\t\\tif(err) {\\n\\t\\t\\t\\t\\treturn callback(err);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tself.logger.log(\\\"Saved file\\\",fileInfo.filepath);\\n\\t\\t\\t\\t_finish();\\n\\t\\t\\t});\\n\\t\\t}\\n\\t});\\n};\\n\\n/*\\nLoad a tiddler and invoke the callback with (err,tiddlerFields)\\n\\nWe don't need to implement loading for the file system adaptor, because all the tiddler files will have been loaded during the boot process.\\n*/\\nFileSystemAdaptor.prototype.loadTiddler = function(title,callback) {\\n\\tcallback(null,null);\\n};\\n\\n/*\\nDelete a tiddler and invoke the callback with (err)\\n*/\\nFileSystemAdaptor.prototype.deleteTiddler = function(title,callback,options) {\\n\\tvar self = this,\\n\\t\\tfileInfo = $tw.boot.files[title];\\n\\t// Only delete the tiddler if we have writable information for the file\\n\\tif(fileInfo) {\\n\\t\\t// Delete the file\\n\\t\\tfs.unlink(fileInfo.filepath,function(err) {\\n\\t\\t\\tif(err) {\\n\\t\\t\\t\\treturn callback(err);\\n\\t\\t\\t}\\n\\t\\t\\tself.logger.log(\\\"Deleted file\\\",fileInfo.filepath);\\n\\t\\t\\t// Delete the metafile if present\\n\\t\\t\\tif(fileInfo.hasMetaFile) {\\n\\t\\t\\t\\tfs.unlink(fileInfo.filepath + \\\".meta\\\",function(err) {\\n\\t\\t\\t\\t\\tif(err) {\\n\\t\\t\\t\\t\\t\\treturn callback(err);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcallback(null);\\n\\t\\t\\t\\t});\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcallback(null);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t} else {\\n\\t\\tcallback(null);\\n\\t}\\n};\\n\\nif(fs) {\\n\\texports.adaptorClass = FileSystemAdaptor;\\n}\\n\\n})();\\n\",\n            \"title\": \"$:/plugins/tiddlywiki/filesystem/filesystemadaptor.js\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"syncadaptor\"\n        },\n        \"$:/plugins/tiddlywiki/filesystem/readme\": {\n            \"title\": \"$:/plugins/tiddlywiki/filesystem/readme\",\n            \"text\": \"The filesystem plugin is used under Node.js to synchronise tiddler changes back to the file system. It is inert when used in the browser.\\n\\n[[Source code|https://github.com/Jermolene/TiddlyWiki5/blob/master/plugins/tiddlywiki/filesystem]]\\n\"\n        }\n    }\n}"
}